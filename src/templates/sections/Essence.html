<section class="main__section" id="Essence">
	<h2 class="main__section-header">Суть метода</h2>
	<p>
		Введите произвольный текст в первое текстовое поле (можно чередовать строчные и прописные буквы русского или
		английского языков) и выберите значение ключа. Во втором текстовом поле вы увидите что-то странное...
	</p>
	<div class="textarea">
		<div class="textarea__col">
			<h3 class="textarea__header">Исходный текст:</h3>
			<textarea
				id="textareaI_IN"
				class="textarea__control"
				rows="10"
				cols="20"
				placeholder="Введите тайное послание..."
			></textarea>
		</div>
		<div class="textarea__key">
			<h3 class="textarea__header">Ключ:</h3>
				<input type="number" value="0" min="0" step="1" class="textarea__key-input" id="inputI_KEY">
			<div class="textarea__buttons">
				<button id="buttonI_minus" class="textarea__button">-</button>
				<button id="buttonI_plus" class="textarea__button">+</button>
			</div>
		</div>
		<div class="textarea__col">
			<h3 class="textarea__header">Шифртекст:</h3>
			<textarea
				id="textareaI_OUT"
				class="textarea__control"
				rows="10"
				cols="20"
				readonly
			></textarea>
		</div>
	</div>
	<p>
		Поздравляю, вы только что зашифровали свой текст! Теперь ваша информация будет в безопасности (какое-то время).
		Полученное зашифрованное сообщение принято называть <b>шифртекстом</b>, а то, с помощью чего был зашифрован
		исходный текст – <b>ключом шифрования</b>. Для метода Цезаря, зная ключ, можно с лёгкостью расшифровать сообщение
		(впрочем, не зная его, расшифровать тоже не составит труда, что мы покажем далее). Такой вид шифрования
		называется <b>симметричным</b>, поскольку и при шифровании, и при дешифровании используется один и тот же ключ.
		Попробуйте выбрать другое значения ключа и посмотрите, что получится.
	</p>
	<p>
		А теперь сотрите всё, что вы там зашифровали, и введите в строку последовательно все буквы русского (английского)
		алфавита по порядку и выберите значение ключа. Только не говорите, что не помните алфавит на память. Ладно, так и
		быть, можете нажать на ссылки, и алфавиты вставятся сами (<a href="#" id="insertCYR" class="insert-text-link">
		русский</a>, <a href="#" id="insertLAT" class="insert-text-link">английский</a>, кликабельно).
	</p>
	<p>
		Обратите внимание, что шифртекст в точности совпадает с исходным текстом, но с одной особенностью – он как будто
		бы сдвинут влево на некоторое количество символов, а сдвинутые начальные символы переместились в конец
		шифртекста. Кажется, вы начинаете понимать, не так ли? Именно в этом и заключается суть метода шифрования Цезаря
		– каждый символ в исходном тексте заменяется символом, находящимся на <b>некотором постоянном смещении</b> от
		него в алфавите, а это смещение и есть ключ.
	</p>
	<p>
		Сейчас будет немного математики, но не пугайтесь, она несложная, просто с помощью неё гораздо удобнее описать
		процесс шифрования/дешифрования (картинки честно украдены с <a
		href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80_%D0%A6%D0%B5%D0%B7%D0%B0%D1%80%D1%8F">Википедии</a>):
	</p>
	<div class="main__section-formulas">
		<img class="main__section-formula"
		     src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ec7a78025d3d44bece6d9880ad58ad131ac013fa"
		     alt="Формула дешифрования по методу Цезаря">
		<img class="main__section-formula"
		     src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2417bfd08b8fa32adcabd255bb9a6b20832ca47f"
		     alt="Формула шифрования по методу Цезаря">
	</div>
	<p>
		где x – символ исходного сообщения, y – символ шифртекста, n – число букв в алфавите, k – ключ шифрования, mod –
		операция взятия остатка от деления. Как видите, всё очень просто.
	</p>
	<details class="spoiler">
		<summary class="spoiler__summary">
			<span class="spoiler__title">Для тех, кому не очень просто (или вообще ни разу не просто)</span>
		</summary>
		<ol class="algorithm" type="1">
			<li class="algorithm__item">
				Предположим, мы захотели отправить некоторые важные сведения своему другу, например, что вечером в магазин
				привезут свежий хлеб, и чтобы успеть его купить, нельзя допустить, чтобы остальные узнали об этом, иначе на
				свежачок сбежится весь город. Для этого нужно предварительно договориться о ключе, которым вы оба будете пользоваться в ваших
				тайных переписках. Пусть ключ будет равен 10.
			</li>
			<li class="algorithm__item">
				Вы пишите записку, например, "<b>сегодня вечером будет привоз	хлеба</b>" (для повышения секретности можно
				написать "орел, кукушка в гнезде, кукушка в гнезде", а ваш друг, проявив чудеса дедукции, догадается, что вы на
				самом деле имели ввиду). Используя вторую формулу, вы начинаете побуквенно его шифровать:
				<ol class="algorithm">
					<li class="algorithm__item">
						В первом слове буква "с" в алфавите имеет порядковый номер 19 (под рукой желательно иметь таблицу с
						буквами), ключ равен 10, следовательно, первая буква шифртекста будет иметь порядковый номер в алфавите
						19+10=29, то есть "ы".
						<img
							class="algorithm__image"
							src="assets/images/russian-letters-table.webp"
							alt="Russian letters table"/>
					</li>
					<li class="algorithm__item">
						Вторая буква исходного сообщения шифруется аналогично – "е" в алфавите имеет порядковый номер 6, после
						шифрования она превращается в букву "о" (порядковый номер 6+10=16).
					</li>
					<li class="algorithm__item">
						Последующие символы вашего текста шифруются аналогично. В итоге вы получите шифртекст "<b>ыомшнчи лобоъшц
						кэноь щътлшс яхокй</b>".
					</li>
				</ol>
			</li>
			<li class="algorithm__item">
				Вы отправляете гонца с зашифрованной запиской вашему другу (напоминаю, гонец понятия не имеет, что содержится
				в записке, и уж тем более не знает ключа).
			</li>
			<li class="algorithm__item">
				Ваш друг получает ваш шифртекст и, используя известный только вам двоим ключ, начинает дешифровать текст по
				первой формуле, но думаю, вы и так догадываетесь, что в данном случае надо вычитать значение ключа из позиции
				буквы в алфавите. Но давайте проделаем это для наглядости:
				<ol class="algorithm">
					<li class="algorithm__item">
						В первом слове шифтекста буква "ы" в алфавите имеет порядковый номер 29, ключ равен 10, следовательно, первая буква исходного сообщения	будет иметь порядковый номер в алфавите 29-10=19, то есть "с".
					</li>
					<li class="algorithm__item">
						Вторая буква шифтекста дешифруется аналогично – "о" в	алфавите имеет порядковый номер 16, после
						дешифрации она превращается в букву "е" (порядковый номер 16-10=6).
					</li>
					<li class="algorithm__item">
						Последующие символы шифртекста дешифруются аналогично. В итоге ваш друг получит исходное сообщение и
						обрадуется, ведь наконец-то у него	есть шанс вкусить свежего хлеба.
					</li>
				</ol>
			</li>
			<li class="algorithm__item">
				Погодите-ка, скажите вы, а что будет, если сумма позиции буквы и ключа будет больше порядкового номера
				последней буквы алфавита? Например, как зашифровать	букву "ч" (позиция 25) при длине ключа 10? Это что же
				получается, надо взять 35-ую букву алфавита??? Нет, это не шарлотанство – надо брать не просто 35-ую
				букву, а 35-ую букву <b>по модулю длины алфавита</b>, или же взять остаток от деления 35/33, т.е. 2. А этой
				позиции соотвуетствует буква "б". Таким образом обеспечивается <b>циклический	сдвиг</b>, алфавит
				закольцовывается, и после последней буквы вновь пойдёт	первая. <small>и после этого вы понимаете, что ничего
				уже не понимаете</small>
				<br>
				<u>Интересное следствие</u>: ключ 34 будет равен ключу 1. И даже ключ 1090 будет равен ему же. То есть всего
				возможных ключей шифрования будет на единицу меньше, чем букв в исходном алфавите (и тут вы осознали, что
				китайцы хитрее, чем кажутся).
			</li>
		</ol>
	</details>
</section>
